---
title: "ğŸ—ºï¸ Fundamentals of Map Design with `mapgl`"
author: "DS 421 â€“ Cartographic Design"
date: "2025"
format:
  html:
    toc: true
    code-fold: true
    theme: minty
    css: styles.css
    self-contained: false
execute:
  eval: false  # prevent chunk execution on render
---

Welcome to your first creative exploration of **map design using R and the `mapgl` package**! In this tutorial, you'll:

-   Load spatial data using `tidycensus`
-   Create your first interactive maps with `mapgl`
-   Learn both **continuous** and **categorical** styling methods
-   Add interactivity like **tooltips** and **hover effects**

Letâ€™s dive in!

------------------------------------------------------------------------

## ğŸ“¦ Getting Started

Make sure youâ€™ve installed the required packages:

Load libraries:

```{r}
library(tidyverse)
library(tidycensus)
library(mapgl)
library(viridisLite)
library(RColorBrewer)
library(glue)
```

------------------------------------------------------------------------

## ğŸ§­ Load Hawaii Median House Hold Income Data

To create a meaningful map, we need **geospatial data** â€” data that includes both attributes (e.g. median age) and geometry (e.g. Census tract boundaries).

The `tidycensus` package allows us to pull **American Community Survey (ACS)** data directly from the U.S. Census Bureau. When you use `geometry = TRUE`, youâ€™re telling R to return spatial features (polygons, points, or lines) alongside the statistics.

Letâ€™s look at what weâ€™re loading:

```{r}
hi_median_income <- get_acs(
  geography = "tract",
  variables = "B19013_001",  # median income
  state = "HI",
  year = 2023,
  geometry = TRUE
)

```

### ğŸ‘€ Explore the Data in the Viewer

Click on `hi_median_income` in your **Environment tab** or run `View(hi_median_income)` to open it as a spreadsheet.

Notice: - The `estimate` column shows the median age - The `geometry` column contains spatial polygons (`MULTIPOLYGON`) - This is an **`sf` object**, which stands for *Simple Features* â€” this is what makes the data "mappable" in R

> âœ… If your data has a `geometry` column and `sf` class, itâ€™s ready for cartographic visualization!

> âœ… Now lets plot an interactive map centered on Hawaii

------------------------------------------------------------------------

### Draw a blank map of Hawaii

```{r}
hi_map <- mapboxgl(mapbox_style("light"), bounds = hi_median_income)

hi_map
```

## ğŸ¨ Continuous Styling

One of the most important choices in cartographic design is **how to represent your data visually** â€” especially when it comes to **color**. Should you show your data as a **smooth gradient** or in **distinct categories**? That choice sends a message.

**Continuous color scales** use gradients to show smooth variation in a numeric variable â€” like temperature, elevation, or median age. These are great when:

-   You want to emphasize gradual change
-   The viewer should see subtle differences between areas
-   You want the map to feel intuitive and data-rich

For example, a continuous palette of deep blue to light blue can subtly show where the median income is lower vs. higher â€” without imposing artificial boundaries.

When designing with continuous color, think of it like painting with light: smooth tones invite exploration, nuance, and *feel* more natural.

Hereâ€™s how we apply a continuous color scale to median income:

```{r}
continuous_scale <- interpolate_palette(
  data = hi_median_income,
  column = "estimate",
  method = "equal",
  n = 5,
  palette = magma
)

hi_map |>
  add_fill_layer(
    id = "hi_tracts",
    source = hi_median_income,
    fill_color = continuous_scale$expression,
    fill_opacity = 0.5
  ) |>
  add_legend(
    "Median Income in Hawaii",
    values = get_legend_labels(continuous_scale, digits = 0),
    colors = get_legend_colors(continuous_scale),
    type = "continuous"
  )
```

------------------------------------------------------------------------

### ğŸ§© **Challenge #1** â€“ Try a Different Color Scheme

Replace `plasma` with another palette (e.g., `viridis`, `magma`, or `cividis`). Which one feels the most readable? Why?

```{r}
plasma = magma()
```

------------------------------------------------------------------------

## ğŸ§® Manual Styling with Interpolation

Lets see the min and max of median income

```{r}
min(hi_median_income$estimate, na.rm = TRUE)
max(hi_median_income$estimate, na.rm = TRUE)
```

What does this look like with other data viz?

```{r}
ggplot(hi_median_income, aes(x = estimate)) +
  geom_histogram(fill = "steelblue", color = "black") +
  theme_minimal()
  
```

```{r}
hi_map |>
  add_fill_layer(
    id = "hi_tracts",
    source = hi_median_income,
    fill_color = interpolate(
      column = "estimate",
      values = c(20000, 250000),
      stops = c("lightblue", "darkblue"),
      na_color = "lightgrey"
    ),
    fill_opacity = 0.5
  ) |>
  add_legend(
    "Median Income in Hawaii",
    values = c(20000, 250000),
    colors = c("lightblue", "darkblue")
  )
```

------------------------------------------------------------------------

## ğŸ”¢ Categorical Styling

In contrast to smooth gradients, **classified (categorical) color scales** divide your data into clear buckets. This approach is especially helpful when:

-   You want to simplify complex data
-   The audience needs clear takeaways (e.g., policy decisions, eligibility zones)
-   Youâ€™re emphasizing **differences** between areas

Instead of saying â€œthis place is a bit older,â€ a categorical map might say â€œthis tract is in the highest 20%. for median incomeâ€ This clarity is powerful â€” but it also means youâ€™re drawing visual boundaries that might not exist in reality.

As a cartographer, **you are making choices that influence interpretation**. Use this power carefully.

When designing categorical maps: - Choose palettes that are **visually distinct** (e.g., `RColorBrewer::brewer.pal()`) - Keep the number of categories reasonable (usually 4â€“7) - Match color progression to the narrative â€” e.g., darker = more intense

> ğŸ¨ A good map doesnâ€™t just show data â€” it **communicates purpose** through design.

Hereâ€™s how we apply quantile classification to Hawaii's Median Income:

```{r}
q_class <- step_quantile(
  data = hi_median_income,
  column = "estimate",
  n = 5,
  colors = RColorBrewer::brewer.pal(5, "PRGn")
)

hi_map |>
  add_fill_layer(
    id = "hi_tracts",
    source = hi_median_income,
    fill_color = q_class$expression,
    fill_opacity = 0.5
  ) |>
  add_legend(
    "Median Income in Hawaii",
    values = get_legend_labels(q_class, digits = 0, suffix = " $"),
    colors = get_legend_colors(q_class),
    type = "categorical"
  )
```

------------------------------------------------------------------------

### ğŸ§© **Challenge #2** â€“ Classify Differently

Letâ€™s apply your design instincts!

Try switching from `step_quantile()` to one of the following:

-   `step_equal_interval()` â€“ evenly spaced numeric breaks
-   `step_jenks()` â€“ natural breaks that minimize variance within groups

Type `?step_quantile` in your console to see definitions

How does your choice affect the message your map conveys?

ğŸ’¬ *What looks more balanced? Which palette aligns with your intended story?*

Write 1â€“2 sentences reflecting on the **cartographic message** your choices imply.

------------------------------------------------------------------------

## Question: What is the poverty line for a household in Hawaii?

Can we create a map that only shows above/below the poverty line

```{r}
hi_median_income <- hi_median_income |>
  mutate(
    mit_threshold = ifelse(estimate < 107689, "Below Line", "Above Line")
  )
```

```{r}
mit_colors <- c("Below Line" = "#d73027", "Above Line" = "#1a9850")

mapboxgl(bounds = hi_median_income) |>
  add_fill_layer(
    id = "hi_tracts",
    source = hi_median_income,
    fill_color = match_expr(
      column = "mit_threshold",
      values = names(mit_colors),
      stops = unname(mit_colors)
    ),
    fill_opacity = 0.6
  ) |>
  add_legend(
    "Median Income Status",
    values = names(mit_colors),
    colors = unname(mit_colors),
    type = "categorical"
  )


```

## Question: How else can we think about the poverty line and map?

Hints : <https://livingwage.mit.edu/states/15>, <https://unitedforalice.org/hawaii>

### ğŸ§© **Challenge #3** â€“ Classify Differently

Make a binary map, two colors, representing above and below a threshold of median income that you determine based on an outside source like the ones hinted above

## âœ¨ Add Interactivity

```{r}
hi_median_income$popup <- glue(
  "<strong>Tract:</strong> {hi_median_income$NAME}<br><strong>Median income:</strong> {hi_median_income$estimate}"
)

hi_map |>
  add_fill_layer(
    id = "hi_tracts",
    source = hi_median_income,
    fill_color = interpolate(
      column = "estimate",
      values = c(20000, 250000),
      stops = c("lightblue", "darkblue"),
      na_color = "lightgrey"
    ),
    fill_opacity = 0.5,
    popup = "popup",
    tooltip = "estimate",
    hover_options = list(
      fill_color = "yellow",
      fill_opacity = 1
    )
  ) |>
  add_legend(
    "Median Income in Hawaii",
    values = c(20000, 250000),
    colors = c("lightblue", "darkblue")
  )
```

------------------------------------------------------------------------

### ğŸ§© **Challenge #4** â€“ Customize a Tooltip

Make your map more personal and informative!

Instead of just `estimate`, add other descriptive info in your popup. For example, use `NAME` (tract name) or `GEOID` along with the estimate.

```{r}
hi_median_income$popup <- glue(
  "<strong>Tract:</strong> {hi_median_income$NAME}<br><strong>Median income:</strong> {hi_median_income$estimate}"
)
```

Bonus: Try replacing `fill_color = "yellow"` with a color of your choice that aligns better with your mapâ€™s aesthetic.

> ğŸ’¡ Cartographic design is about more than color â€” itâ€™s about **clarity, context, and care** in visual choices.

------------------------------------------------------------------------

## ğŸŒŸ Challenge #5 â€“ Your Own Data!

Load median income, rent, or internet access for a different state using `tidycensus`. Here are a few suggestions: Use whatever state and variable you would like. You can also type this prompt into chat gpt: "what is the census code using tidycensus in R for median age?". It will most likely give you the correct variable code. Mao your variables using mapgl

| Variable   | Description              |
|------------|--------------------------|
| B01002_001 | Median age               |
| B25077_001 | Median home value        |
| B28002_004 | Households with internet |

```{r}
acs_vars <- load_variables(2022, "acs5", cache = TRUE)
```

#### A California Example

```{r}
library(tidyverse)
library(tidycensus)
library(mapgl)
library(viridisLite)

# (Optional) Browse ACS variable names
acs_vars <- load_variables(2022, "acs5", cache = TRUE)

# Example: quickly find the code for â€œMedian ageâ€
acs_vars %>% filter(str_detect(label, regex("^Median age", ignore_case = TRUE))) %>% head()


```
```{r}
ak_income <- get_acs(
  geography = "tract",
  variables = "B19013_001",  # median household income
  state = "AK",
  year = 2023,
  geometry = TRUE
)

ak_scale <- interpolate_palette(
  data   = ak_income,
  column = "estimate",
  method = "equal",   # try "quantile" or "jenks" too
  n      = 5,
  palette = viridis   # try magma / plasma / cividis
)

mapboxgl(bounds = ak_income) |>
  add_fill_layer(
    id = "ak_income_tracts",
    source = ak_income,
    fill_color = ak_scale$expression,
    fill_opacity = 0.55,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Median household income â€“ Alaska",
    values = get_legend_labels(ak_scale, digits = 0, prefix = "$"),
    colors = get_legend_colors(ak_scale),
    type = "continuous"
  )
```
```{r}
ak_home_value <- get_acs(
  geography = "tract",
  variables = "B25077_001",  # median home value
  state = "AK",
  year = 2023,
  geometry = TRUE
)

ak_hv_scale <- interpolate_palette(
  data   = ak_home_value,
  column = "estimate",
  method = "quantile",
  n      = 5,
  palette = cividis
)

mapboxgl(bounds = ak_home_value) |>
  add_fill_layer(
    id = "ak_homevalue_tracts",
    source = ak_home_value,
    fill_color = ak_hv_scale$expression,
    fill_opacity = 0.55,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Median home value â€“ Alaska",
    values = get_legend_labels(ak_hv_scale, digits = 0, prefix = "$"),
    colors = get_legend_colors(ak_hv_scale),
    type = "continuous"
  )

```
```{r}
ak_internet <- get_acs(
  geography = "tract",
  variables = "B28002_004",  # households with internet
  state = "AK",
  year = 2023,
  geometry = TRUE
)

ak_net_scale <- interpolate_palette(
  data   = ak_internet,
  column = "estimate",
  method = "equal",
  n      = 5,
  palette = plasma
)

mapboxgl(bounds = ak_internet) |>
  add_fill_layer(
    id = "ak_internet_tracts",
    source = ak_internet,
    fill_color = ak_net_scale$expression,
    fill_opacity = 0.55,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Households with internet â€“ Alaska",
    values = get_legend_labels(ak_net_scale, digits = 0),
    colors = get_legend_colors(ak_net_scale),
    type = "continuous"
  )

```

ğŸ” Try: - Changing the variable to median home value- Switching the state (e.g., "HI", "NY", "TX") - Using a different styling function
```{r}
# Median household income in Massachusetts
ma_income <- get_acs(
  geography = "tract",
  variables = "B19013_001",  # median household income
  state = "MA",
  year = 2023,
  geometry = TRUE
)

# Create a pink scale (from light to dark pink)
pink_scale <- interpolate_palette(
  data   = ma_income,
  column = "estimate",
  method = "quantile",    # could also try "equal" or "jenks"
  n      = 5,
  palette = function(n) grDevices::colorRampPalette(c("#fde0dd", "#fa9fb5", "#c51b8a"))(n)
)

# Map
mapboxgl(bounds = ma_income) |>
  add_fill_layer(
    id = "ma_income_tracts",
    source = ma_income,
    fill_color = pink_scale$expression,
    fill_opacity = 0.6,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Median household income â€“ Massachusetts",
    values = get_legend_labels(pink_scale, digits = 0, prefix = "$"),
    colors = get_legend_colors(pink_scale),
    type = "continuous"
  )

```
```{r}
# Households with internet access in Massachusetts
ma_internet <- get_acs(
  geography = "tract",
  variables = "B28002_004",  # households with internet
  state = "MA",
  year = 2023,
  geometry = TRUE
)

# Custom pink gradient (light â†’ dark pink)
pink_net_scale <- interpolate_palette(
  data   = ma_internet,
  column = "estimate",
  method = "quantile",   # try "equal" too
  n      = 5,
  palette = function(n) grDevices::colorRampPalette(
    c("#fde0dd", "#fa9fb5", "#c51b8a")
  )(n)
)

# Map
mapboxgl(bounds = ma_internet) |>
  add_fill_layer(
    id = "ma_internet_tracts",
    source = ma_internet,
    fill_color = pink_net_scale$expression,
    fill_opacity = 0.6,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Households with Internet â€“ Massachusetts",
    values = get_legend_labels(pink_net_scale, digits = 0),
    colors = get_legend_colors(pink_net_scale),
    type = "continuous"
  )

```
```{r}
library(tidyverse)
library(tidycensus)
library(mapgl)

# Pretty pink palette
pink_pal <- function(n) grDevices::colorRampPalette(
  c("#fde0dd", "#fa9fb5", "#c51b8a")
)(n)

# Pull median income for HawaiÊ»i County (Big Island)
hi_income <- get_acs(
  geography = "tract",
  variables = "B19013_001",   # median household income
  state = "HI",
  county = "Hawaii",          # ğŸ‘ˆ limits to Big Island
  year = 2023,
  geometry = TRUE
)

# Pull households with internet for HawaiÊ»i County
hi_internet <- get_acs(
  geography = "tract",
  variables = "B28002_004",   # households with internet
  state = "HI",
  county = "Hawaii",
  year = 2023,
  geometry = TRUE
)

```
```{r}
# Put this near the top of your .qmd
options(tigris_use_cache = TRUE)   # cache shapes on your Mac
options(tigris_class = "sf")       # return sf objects
options(timeout = 600)             # avoid timeout on slow wifi

# Optional: simpler shapes = faster download/render
# (works through tidycensus -> tigris)
# Example:
hi_income <- get_acs(
  geography = "tract",
  variables = "B19013_001",
  state = "HI",
  county = "Hawaii",
  year = 2023,
  geometry = TRUE,
  cb = TRUE          # <= cartographic boundary (simplified geometry)
)

```#| message: false
#| warning: false
```

```{r}
#| label: map-big-island-income-pink
#| echo: false
#| message: false
#| warning: false

# Pink palette (light â†’ dark)
pink_pal <- function(n) grDevices::colorRampPalette(
  c("#fde0dd", "#fa9fb5", "#c51b8a")
)(n)

# Build a color scale for the map (quantile = nice balanced breaks)
income_scale <- interpolate_palette(
  data   = hi_income,        # <- uses the object you already created
  column = "estimate",
  method = "quantile",       # try "equal" or "jenks" if you want
  n      = 5,
  palette = pink_pal
)

# Draw the map
mapboxgl(bounds = hi_income) |>
  add_fill_layer(
    id = "hi_income_tracts",
    source = hi_income,
    fill_color = income_scale$expression,
    fill_opacity = 0.65,
    tooltip = "estimate"      # hover shows the number
  ) |>
  add_legend(
    "Median Household Income â€“ HawaiÊ»i Island",
    values = get_legend_labels(income_scale, digits = 0, prefix = "$"),
    colors = get_legend_colors(income_scale),
    type = "continuous"
  )

```
```{r}
#| label: map-big-island-income-sparkly
#| echo: false
#| message: false
#| warning: false

# Define a fun, sparkly rainbow palette
sparkly_pal <- function(n) grDevices::colorRampPalette(
  c("#ff66c4", "#ffde59", "#5ce1e6", "#8c52ff", "#ff914d")
)(n)

# Build a color scale for HawaiÊ»i Island income
sparkly_scale <- interpolate_palette(
  data   = hi_income,        # your object with income data
  column = "estimate",
  method = "quantile",       # divides values into 5 even groups
  n      = 5,
  palette = sparkly_pal
)

# Draw the colorful map
mapboxgl(bounds = hi_income) |>
  add_fill_layer(
    id = "hi_income_sparkly",
    source = hi_income,
    fill_color = sparkly_scale$expression,
    fill_opacity = 0.7,
    tooltip = "estimate"
  ) |>
  add_legend(
    "Median Household Income â€“ HawaiÊ»i Island",
    values = get_legend_labels(sparkly_scale, digits = 0, prefix = "$"),
    colors = get_legend_colors(sparkly_scale),
    type = "continuous"
  )

```

------------------------------------------------------------------------

## âœ… Summary

Youâ€™ve now:

-   Built your first interactive map with `mapgl`
-   Explored **color palettes**, **classifications**, and **interactivity**
-   Experimented with **continuous vs categorical** styling
-   Learned how to **guide your reader** with popups and hover design

ğŸ¯ Youâ€™re on your way to designing thoughtful, expressive cartographic products.

Save and push your.qmd file to github to earn credit for the challenges!